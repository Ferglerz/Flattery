// Surround FFT Flattener - IIR Peaking Filters
// Biquad peaking filters for frequency-dependent gain control

@init

// IIR filter state structure per filter:
// [x1, x2, y1, y2] - delay line samples
// Each filter needs 4 state variables per channel

// Initialize filter bank (call after sff_init_filter_frequencies)
function sff_init_filter_bank() local(i, n_filters, top) (
  n_filters = sff_filter_count;
  
  // Allocate filter state memory (after filter frequencies)
  // Each filter: 4 state vars per channel (x1, x2, y1, y2)
  // Left and right channels separate
  sff_filter_state_L = sff_filter_freq_base + 256;  // After frequency array
  sff_filter_state_R = sff_filter_state_L + n_filters * 4;
  
  // Allocate filter coefficients
  // Each filter: 5 coefficients (b0, b1, b2, a1, a2)
  sff_filter_coeffs = sff_filter_state_R + n_filters * 4;
  
  // Allocate filter gains (linear, updated from FFT analysis)
  sff_filter_gains = sff_filter_coeffs + n_filters * 5;
  
  // Allocate previous filter gains for rate of change tracking
  sff_filter_gains_prev = sff_filter_gains + n_filters;
  
  // Allocate tilt multiplier cache (cached tilt multipliers per filter frequency)
  sff_filter_tilt_multipliers = sff_filter_gains_prev + n_filters;
  
  top = sff_filter_tilt_multipliers + n_filters;
  freembuf(top);
  
  // Clear all filter states
  memset(sff_filter_state_L, 0, n_filters * 4);
  memset(sff_filter_state_R, 0, n_filters * 4);
  
  // Initialize all gains to unity (no processing)
  i = 0;
  loop(n_filters,
    sff_filter_gains[i] = 1.0;
    sff_filter_gains_prev[i] = 1.0;
    i += 1;
  );
  
  // Initialize unity cache flag (all filters start at unity)
  sff_filters_all_unity_cached = 1;
  
  // Initialize active filter range (all filters active by default)
  sff_active_filter_start = 0;
  sff_active_filter_end = n_filters;
  
  // Note: Filter coefficients will be updated by caller via sff_update_filter_coeffs()
  // This ensures proper function definition order (functions must be defined before use in JSFX)
);

// Calculate biquad peaking filter coefficients
// Based on RBJ Audio EQ Cookbook
// When gain_linear = 1.0, filter should be allpass (transparent)
function sff_calculate_peaking_coeffs(filter_idx, center_hz, q, gain_linear) local(
  w, cos_w, sin_w, alpha, A, b0, b1, b2, a0, a1, a2, coeff_base, gain_diff, srate_inv, q_inv, a0_inv, A_inv
) (
  // Check if gain is close enough to 1.0 to use allpass
  gain_diff = abs(gain_linear - 1.0);
  gain_diff < 0.001 ? (
    // When gain = 1.0, peaking filter reduces to allpass
    // For allpass: use identity filter (output = input, no processing)
    // This is the safest approach - completely bypass the filter
    coeff_base = filter_idx * 5;
    // Identity filter: b0 = 1.0, all other coefficients = 0.0
    // This gives: output = 1.0 * input + 0.0 * x1 + 0.0 * x2 - 0.0 * y1 - 0.0 * y2 = input
    sff_filter_coeffs[coeff_base + 0] = 1.0;  // b0 = 1.0 (pass through)
    sff_filter_coeffs[coeff_base + 1] = 0.0; // b1 = 0.0
    sff_filter_coeffs[coeff_base + 2] = 0.0; // b2 = 0.0
    sff_filter_coeffs[coeff_base + 3] = 0.0; // a1 = 0.0
    sff_filter_coeffs[coeff_base + 4] = 0.0; // a2 = 0.0
  ) : (
    srate_inv = 1.0 / (srate + eps);
    q_inv = 1.0 / (q + eps);
    w = 2.0 * $pi * center_hz * srate_inv;
    cos_w = cos(w);
    sin_w = sin(w);
    
    // Q-based bandwidth (narrower Q for more precise frequency control)
    // Q of 2.0 gives ~1/3 octave bandwidth
    alpha = sin_w * (0.5 * q_inv);
    
    // Gain (when gain_linear = 1.0, filter should be transparent)
    A = sqrt(max(gain_linear, eps));
    A_inv = 1.0 / A;
    
    // Calculate coefficients for peaking filter
    b0 = 1.0 + alpha * A;
    b1 = -2.0 * cos_w;
    b2 = 1.0 - alpha * A;
    a0 = 1.0 + alpha * A_inv;
    a1 = -2.0 * cos_w;
    a2 = 1.0 - alpha * A_inv;
    
    // Normalize by a0 (cache inverse for multiplication)
    a0_inv = 1.0 / a0;
    coeff_base = filter_idx * 5;
    sff_filter_coeffs[coeff_base + 0] = b0 * a0_inv;  // b0
    sff_filter_coeffs[coeff_base + 1] = b1 * a0_inv;  // b1
    sff_filter_coeffs[coeff_base + 2] = b2 * a0_inv;  // b2
    sff_filter_coeffs[coeff_base + 3] = a1 * a0_inv;  // a1
    sff_filter_coeffs[coeff_base + 4] = a2 * a0_inv;  // a2
  );
);

// Update all filter coefficients based on current sample rate
function sff_update_filter_coeffs() local(i, center_hz, q, gain_linear) (
  // Use high Q (narrow bandwidth) to minimize filter overlap
  // Q of 10.0 gives ~1/15 octave bandwidth - very narrow, minimal overlap
  // This prevents gains from multiplying when filters are in series
  q = 10.0;
  
  i = 0;
  loop(sff_filter_count,
    center_hz = sff_filter_freq[i];
    gain_linear = sff_filter_gains[i];
    sff_calculate_peaking_coeffs(i, center_hz, q, gain_linear);
    i += 1;
  );
);

// Update cached unity flag (call after filter gains change)
function sff_update_unity_cache_flag() local(i) (
  sff_filters_all_unity_cached = 1;
  i = 0;
  loop(sff_filter_count,
    abs(sff_filter_gains[i] - 1.0) > 0.001 ? (
      sff_filters_all_unity_cached = 0;
      i = sff_filter_count;  // Exit early
    );
    i += 1;
  );
);

// Update active filter range based on cut frequencies
function sff_update_active_filter_range() local(i, j) (
  // Find first filter >= low_cut
  sff_active_filter_start = 0;
  i = 0;
  loop(sff_filter_count,
    sff_filter_freq[i] >= sff_low_cut_hz_cached ? (
      sff_active_filter_start = i;
      i = sff_filter_count;  // Exit
    );
    i += 1;
  );
  
  // Find last filter <= high_cut (iterate backwards)
  sff_active_filter_end = sff_filter_count;
  i = sff_filter_count - 1;
  j = 0;
  loop(sff_filter_count,
    j < sff_filter_count ? (
      sff_filter_freq[i] <= sff_high_cut_hz_cached ? (
        sff_active_filter_end = i + 1;
        j = sff_filter_count;  // Exit by making counter exceed limit
      ) : (
        i -= 1;
        j += 1;
      );
    );
    // If j >= sff_filter_count, skip remaining iterations (already found)
  );
);

// Process stereo sample through entire filter bank (PARALLEL topology)
// Each filter processes the input independently, then we sum their contributions
// This prevents gain multiplication that occurs in series topology
// 
// Parallel approach: output = input + sum(filter_i(input) - input)
// Each filter contributes only its DIFFERENCE from the input
// This way filters add their effects rather than multiply
//
// Filters outside low_cut_hz/high_cut_hz range are skipped
// Uses cached cut frequencies (updated in @slider) for immediate response
function sff_process_filter_bank(inputL, inputR) local(i, outputL, outputR, filteredL, filteredR, diffL, diffR, sumL, sumR, state_base, coeff_base, x1_L, x2_L, y1_L, y2_L, x1_R, x2_R, y1_R, y2_R, b0, b1, b2, a1, a2, loop_count) (
  // Bypass if all filters are at unity gain (use cached flag for performance)
  sff_filters_all_unity_cached ? (
    outputL = inputL;
    outputR = inputR;
  ) : (
    // Parallel processing: each filter processes input independently
    // We sum the differences (filter_output - input) from each filter
    sumL = 0.0;
    sumR = 0.0;
    
    // Only process filters in active range (pre-calculated in @slider)
    i = sff_active_filter_start;
    loop_count = sff_active_filter_end - sff_active_filter_start;
    loop(loop_count,
      // Only process filters that are not at unity gain (invert logic to avoid empty branch)
      abs(sff_filter_gains[i] - 1.0) >= 0.001 ? (
        // Pre-calculate array offsets once per filter
        state_base = i * 4;
        coeff_base = i * 5;
        
        // INLINE biquad processing for left channel
        x1_L = sff_filter_state_L[state_base + 0];
        x2_L = sff_filter_state_L[state_base + 1];
        y1_L = sff_filter_state_L[state_base + 2];
        y2_L = sff_filter_state_L[state_base + 3];
        b0 = sff_filter_coeffs[coeff_base + 0];
        b1 = sff_filter_coeffs[coeff_base + 1];
        b2 = sff_filter_coeffs[coeff_base + 2];
        a1 = sff_filter_coeffs[coeff_base + 3];
        a2 = sff_filter_coeffs[coeff_base + 4];
        
        // Biquad filter: y[n] = b0*x[n] + b1*x[n-1] + b2*x[n-2] - a1*y[n-1] - a2*y[n-2]
        filteredL = b0 * inputL + b1 * x1_L + b2 * x2_L - a1 * y1_L - a2 * y2_L;
        
        // Update left channel state
        sff_filter_state_L[state_base + 0] = inputL;
        sff_filter_state_L[state_base + 1] = x1_L;
        sff_filter_state_L[state_base + 2] = filteredL;
        sff_filter_state_L[state_base + 3] = y1_L;
        
        // INLINE biquad processing for right channel
        x1_R = sff_filter_state_R[state_base + 0];
        x2_R = sff_filter_state_R[state_base + 1];
        y1_R = sff_filter_state_R[state_base + 2];
        y2_R = sff_filter_state_R[state_base + 3];
        // Coefficients are the same for both channels (already loaded above)
        
        // Biquad filter: y[n] = b0*x[n] + b1*x[n-1] + b2*x[n-2] - a1*y[n-1] - a2*y[n-2]
        filteredR = b0 * inputR + b1 * x1_R + b2 * x2_R - a1 * y1_R - a2 * y2_R;
        
        // Update right channel state
        sff_filter_state_R[state_base + 0] = inputR;
        sff_filter_state_R[state_base + 1] = x1_R;
        sff_filter_state_R[state_base + 2] = filteredR;
        sff_filter_state_R[state_base + 3] = y1_R;
        
        // Calculate difference: what this filter adds/subtracts
        diffL = filteredL - inputL;
        diffR = filteredR - inputR;
        
        // Accumulate differences
        sumL += diffL;
        sumR += diffR;
      );
      // If filter is at unity gain, skip processing (no-op, no empty branch needed)
      
      i += 1;
    );
    
    // Final output: input + sum of all filter differences
    outputL = inputL + sumL;
    outputR = inputR + sumR;
  );
  
  // Store right channel in global for retrieval
  sff_filter_output_R = outputR;
  
  outputL;  // Return left channel
);

// Get right channel output (called after sff_process_filter_bank)
function sff_get_filter_output_R() (
  sff_filter_output_R;
);

